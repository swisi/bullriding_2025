name: Build Nuitka Windows – Manual

on:
  workflow_dispatch:
    inputs:
      python-version:
        description: Python-Version
        type: string
        default: "3.12"
      project-dir:
        description: Repo-Ordner, in dem dein Code liegt (z. B. . oder backend)
        type: string
        default: "."
      entrypoint:
        description: Pfad zum Python-Entry relativ zu project-dir (z. B. src/app.py). Wird bei Bedarf automatisch gesucht.
        type: string
        default: "app.py"
      build-mode:
        description: Build-Modus (onefile oder standalone)
        type: choice
        options:
          - onefile
          - standalone
        default: standalone
      output-name:
        description: Dateiname ohne Pfad (z. B. app.exe)
        type: string
        default: "Bullriding.exe"
      use-clang:
        description: clang als Compiler verwenden (empfohlen gegen C1002)
        type: boolean
        default: true
      nuitka-extra-args:
        description: Zusätzliche Nuitka-Argumente (Leerzeichen-getrennt)
        type: string
        default: "--nofollow-import-to=sqlalchemy.dialects.oracle*"
      upload-release:
        description: Artefakt zusätzlich an ein GitHub-Release anhängen
        type: boolean
        default: true
      release-tag:
        description: Tag-Name fürs Release (z. B. v1.2.3). Leer lassen, wenn du bereits auf einem Git-Tag baust.
        type: string
        default: ""
      sign-artifacts:
        description: EXE/DLLs nach dem Build signieren (PFX aus Secrets)
        type: boolean
        default: false

jobs:
  nuitka-build:
    name: Nuitka Build (Windows)
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
          lfs: true

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ github.event.inputs['python-version'] }}

      - name: Cache pip (Windows)
        if: hashFiles('**/requirements.txt') != ''
        uses: actions/cache@v4
        with:
          path: ~\AppData\Local\pip\Cache
          key: ${{ runner.os }}-pip-${{ github.event.inputs['python-version'] }}-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies (PowerShell)
        shell: pwsh
        working-directory: ${{ github.workspace }}\${{ github.event.inputs['project-dir'] }}
        run: |
          python -m pip install --upgrade pip
          if (Test-Path "requirements.txt") { pip install -r requirements.txt }
          pip install nuitka

      - name: Validate entrypoint (PowerShell, Auto-Suche + Priorität)
        shell: pwsh
        working-directory: ${{ github.workspace }}\${{ github.event.inputs['project-dir'] }}
        run: |
          $entryRel = "${{ github.event.inputs.entrypoint }}"
          $entryAbs = Resolve-Path -LiteralPath $entryRel -ErrorAction SilentlyContinue

          if (-not $entryAbs) {
            Write-Host "Entrypoint '$entryRel' nicht gefunden. Starte Auto-Suche…"

            $candidateNames   = @('app.py','wsgi.py','main.py','run.py','server.py') # Priorität
            $excludePatterns  = @('\.git', '\.venv', 'env', 'venv', 'node_modules', 'migrations', '\.mypy_cache', '\.pytest_cache')

            $allFiles = Get-ChildItem -Recurse -File -Depth 8 -ErrorAction SilentlyContinue

            $filtered = @()
            foreach ($f in $allFiles) {
              if (-not ($candidateNames -contains $f.Name)) { continue }
              $full = $f.FullName
              $isExcluded = $false
              foreach ($pat in $excludePatterns) {
                if ($full -match $pat) { $isExcluded = $true; break }
              }
              if (-not $isExcluded) { $filtered += $f }
            }

            if ($filtered.Count -eq 0) {
              Write-Host ">>> Inhalt (Top 3 Ebenen) zur Diagnose:"
              Get-ChildItem -Recurse -Depth 3 | Select-Object FullName | Format-Table -AutoSize
              throw "Kein Entrypoint gefunden. Bitte 'project-dir' und 'entrypoint' prüfen."
            }

            $ordered = $filtered | Sort-Object -Property @{ Expression = { [array]::IndexOf($candidateNames, $_.Name) } }, FullName
            $entryAbs = $ordered[0].FullName
            Write-Host "Kandidat gewählt (nach Priorität): $entryAbs"
          }

          "ENTRY_ABS=$entryAbs" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Verwende Entrypoint: $entryAbs"

      - name: Build with Nuitka (PowerShell)
        shell: pwsh
        working-directory: ${{ github.workspace }}\${{ github.event.inputs['project-dir'] }}
        env:
          CL: "/Zm200"                          # mehr Heap für MSVC
          NUITKA_ASSUME_YES_FOR_DOWNLOADS: "1"  # keine interaktiven Prompts
        run: |
          $flags = @()

          if ("${{ github.event.inputs['build-mode'] }}" -eq "onefile") {
            $flags += "--onefile"
            $flags += "--onefile-no-compression"   # weniger AV-Trigger
          } else {
            $flags += "--standalone"
          }

          if ("${{ github.event.inputs.use-clang }}" -eq "true") {
            $flags += "--clang"
          }

          # (Optional) Windows Metadaten – hilft Reputation
          $flags += "--windows-company-name=Bullriding"
          $flags += "--windows-product-name=Bullriding"
          $flags += "--windows-file-description=Bullriding Steuerung"
          $flags += "--windows-file-version=1.0.0.0"
          $flags += "--windows-product-version=1.0.0.0"

          $flags += "--follow-imports"
          $flags += "--output-dir=dist"
          $flags += "--assume-yes-for-downloads"

          # Extra-Args robust tokenisieren; lose "--" entfernen
          $extraRaw = "${{ github.event.inputs['nuitka-extra-args'] }}".Trim()
          if ($extraRaw) {
            $errors = $null
            $tokens = [System.Management.Automation.PSParser]::Tokenize($extraRaw, [ref]$errors)
            $parts  = @()
            foreach ($t in $tokens) {
              if ($t.Type -in @('CommandArgument','String','Number')) {
                $parts += $extraRaw.Substring($t.Start, $t.Length)
              }
            }
            $parts = $parts | Where-Object { $_ -and $_.Trim() -ne '--' }
            $flags += $parts
          }

          $outName = "${{ github.event.inputs['output-name'] }}"
          if ([string]::IsNullOrWhiteSpace($outName)) { $outName = "app.exe" }

          Write-Host "Nuitka Flags: $($flags -join ' ')"
          Write-Host "Entry: $env:ENTRY_ABS"
          Write-Host "Output: $outName"

          python -m nuitka @flags --output-filename="$outName" "$env:ENTRY_ABS"

          Write-Host "dist-Inhalt:"
          Get-ChildItem -Recurse -Force dist | Format-Table -AutoSize

      - name: Prepare code-signing cert (decode PFX)
        if: ${{ github.event.inputs.sign-artifacts == 'true' }}
        shell: pwsh
        run: |
          if (-not "${{ secrets.CS_PFX_B64 }}") { throw "Secret CS_PFX_B64 fehlt." }
          if (-not "${{ secrets.CS_PFX_PASSWORD }}") { throw "Secret CS_PFX_PASSWORD fehlt." }
          $pfxBytes = [Convert]::FromBase64String("${{ secrets.CS_PFX_B64 }}")
          $pfxPath = Join-Path $env:RUNNER_TEMP "codesign.pfx"
          [IO.File]::WriteAllBytes($pfxPath, $pfxBytes)
          "PFX_PATH=$pfxPath" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Code-sign EXE/DLLs (Authenticode)
        if: ${{ github.event.inputs.sign-artifacts == 'true' }}
        shell: pwsh
        run: |
          # signtool lokalisieren
          $signtool = "${env:ProgramFiles(x86)}\Windows Kits\10\bin\x64\signtool.exe"
          if (-not (Test-Path $signtool)) {
            $signtool = "${env:ProgramFiles(x86)}\Microsoft SDKs\ClickOnce\SignTool\signtool.exe"
          }
          if (-not (Test-Path $signtool)) {
            # Versuch via vswhere
            $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
            if (Test-Path $vswhere) {
              $vsPath = & $vswhere -latest -products * -requires Microsoft.Component.MSBuild -property installationPath
              if ($vsPath) {
                $cand = Get-ChildItem "$vsPath" -Recurse -File -Filter signtool.exe -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($cand) { $signtool = $cand.FullName }
              }
            }
          }
          if (-not (Test-Path $signtool)) { throw "signtool.exe nicht gefunden." }

          $files = Get-ChildItem -Recurse -File dist -Include *.exe,*.dll
          if ($files.Count -eq 0) { throw "Keine EXE/DLLs zum Signieren gefunden." }

          foreach ($f in $files) {
            & $signtool sign `
              /fd SHA256 `
              /tr http://timestamp.digicert.com `
              /td SHA256 `
              /f "$env:PFX_PATH" `
              /p "${{ secrets.CS_PFX_PASSWORD }}" `
              "$($f.FullName)"
          }

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: nuitka-windows-${{ github.event.inputs['python-version'] }}
          path: dist/**
          if-no-files-found: error

  release:
    name: (Optional) Release anhängen
    needs: nuitka-build
    # Läuft wenn Upload gewünscht ist UND (bereits auf einem Tag gebaut wird ODER ein release-tag eingegeben wurde)
    if: ${{ github.event.inputs.upload-release == 'true' && (startsWith(github.ref, 'refs/tags/') || github.event.inputs['release-tag'] != '') }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: nuitka-windows-${{ github.event.inputs['python-version'] }}
          path: dist

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: dist/**
          tag_name: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || github.event.inputs['release-tag'] }}
          target_commitish: ${{ github.sha }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
